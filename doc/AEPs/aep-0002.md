    AEP: 2
    Title: A complete develop/publish workflow for Alire crates
    Author: Alejandro R. Mosteo <amosteo@unizar.es>
    Status: Draft
    Created: 06-jul-2020

Abstract
========

Until date, we do not offer guidelines for a complete closed loop on how to use
Alire to develop/publish/update a crate. Likewise, we do not have official
guidelines on how to distribute, outside of the community index, a project that
uses Alire to obtain its dependencies. 

This document discusses a possible solution for both the closed-loop lifecycle
of a crate, and the open-loop distribution of projects/releases that are
themselves not (yet) indexed in Alire.

Rationale
=========

The root of the problem
-----------------------

The file `${crate}/alire/crate.toml` (henceforth, the manifest file) is
currently regenerated from index information during `alr get`, and rewritten
when dependencies are modified via `alr with`. This is a lossy
process (although this could be fixed) in which the manifest becomes
platform-dependent. Hence, we advice against including this
file in version control, and we ask for it to be excluded from sources
submitted to the community index.

Even if this file regeneration were not lossy, machine-generated output mangles the
original formatting. Even with a good pretty-printer for TOML, any comments in
the original file would be lost. This goes against maintainers, that have to
track this manual file somehow, yet exclude it from submissions.

On the other hand, developers publishing code outside of Alire, with
dependencies from Alire, could distribute the manifest file in place and ask
the users to run `alr update` to obtain all dependencies. This is currently
frowned upon, again because this can only work today for manifests that are
platform-independent.

Proposal
--------

Given that Alire's index and operation revolves around manifest files that have
to be manually crafted (at a minimum for submission to the community index), the
proposal is to fully embrace this manual edition and go in Rust's Cargo
direction. That is, make the manifest file a user-edited file only, and put it
under version control.

A problem that Cargo has not is that `alr with` is leveraged to comfortably
edit GPR files, making dependencies available in one step. Thus, there is a
need to keep `alr with` functionality without regenerating the manifest file.
To meet both ends, the proposal is to add a new `${crate}/alire/crate.diff`
file that is machine-generated but also put under version control. Its purpose
is to hold changes that packagers will have to manually make to the manifest,
but that non-packagers may simply leave there for users of their projects. This
is detailed further in the [Implementation](#implementation) section.

Advantages for packagers are:

1. They can format/comment without their editions being lost.
1. The file can be automatically sourced and stitched into the manifest copy 
submitted to the index.
1. More generally, the whole publish process can be automated (see the
[examples](#workflow-examples) section).
1. The file is preserved on `alr get`/`alr with`.

Advantages for regular users:

1. They can use `alr with` as currently, without manually editing the manifest
(for now, for platform-independent crates).
1. They can instruct their users to simply use `alr update`, `alr build`, or
`alr run` to obtain dependencies, build, or run their projects, respectively.
This is analogous to `cargo` usage.

Why not `requirements.txt`
--------------------------

Another possibility would be to go pip's way and have something similar to its
[requirements.txt](#references) file. This file contains a sequence of commands
to pass to `pip install` to recreate the build environment for a project.

The analogy for Alire would be to have a similar file with commands for `alr`.
This has a few drawbacks with no clear advantage over `cargo`'s solution:

1. It does not help packagers, unless we have complete manipulation of the 
manifest file via `alr` commands.
    1. This would be a huge undertaking, just to generate a file that is 
easily maintained by hand.
    1. We would have in practice a duplication of metadata; one copy in the
manifest file and another copy in the requirements file, in two different 
formats.
    1. Same problems with manifest formatting/comments being lost.

Implementation
==============

The proposal relies on the following changes:

- `${crate}/alire/crate.toml` (manifest) is under version control and manually 
edited.
- `${crate}/alire/crate.diff` (delta) is under version control and edited by `alr`.
    - This file contains the changes that are currently done by `alr with`.

At present, `Alire.Roots.Release` loads the current release from the manifest
file, and uses it as the source of "abstract" dependencies.

After the proposal, in addition, the delta file would be loaded to include
further dependencies to those found in the manifest. Only dependencies not
found in the manifest would be added from the delta file (the manifest
overrules the delta file).

During publishing, `alr publish` will check that there are no pending changes in
the delta file that are missing in the manifest. Or, from other point of view,
`alr publish` will remind the packager to include in the manifest the extra 
dependencies found in the delta file.

Migration plan
--------------

A problem with the current situation is that packaged releases do not currently
include the manifest. This would be solved by generating the manifest (as it is
currently done) only for sources not providing one at the expected location.

A .gitignore file should be generated by `alr init` that excluded
`${crate}/alire/cache`, `${crate}/alire/crate.lock`, to avoid confusion, and
the inclusion of `.toml,.diff` files should be made clear in documentation.

Workflow examples
=================

Several use cases are described, with the changes happening to every file
described in this proposal.

Final user downloading an Alire-aware project
---------------------------------------------

1. The user clones a repository or unpacks a source file.
    1. The sources include the ${crate}/alire/crate.{toml,diff} files.
1. The user runs `alr run` to test the application, or
1. The user runs `alr update` + `alr setenv` to edit, or
1. The user runs `alr edit` directly (when it exists).

In all cases, the manifest and optional delta files are already at the expected
location and directly usable by `alr`, transparently to the user.

The user can contribute changes to upstream directly (even if they involve
changes in dependencies, that will be stored in the delta file).

Final user developing with Alire dependencies
---------------------------------------------

1. The user initializes a project with `alr init`.
1. The user adds dependencies with `alr with`.

The dependencies are stored in the delta file instead of the manifest file, but
this is transparent to the user.

Final user distributing an Alire-aware project
----------------------------------------------

1. The user initializes a project with `alr init`.
1. The user adds dependencies with `alr with`.
1. Manifest and delta files are put under version control.
1. The sources are distributed including these Alire files.

The user needs to know the relevance of these files and that they have to be
distributed, just like any Rustacean knows about `Cargo.toml`.

Maintainer publishing to the Alire community index
--------------------------------------------------

1. The maintainer has an Alire-initialized repository.
    1. The manifest file is ready after `init` or manual edition.
1. Regular work on a new release happens.
    1. Some dependency changes end stored in the delta file.
1. The maintainer runs `alr publish`:
    1. `alr` warns that there are dependency changes to be consolidated into
the manifest.
1. Once no changes remain to be consolidated, `alr publish`:
    1. Does the automated steps (zip/hash/upload/clone):
    1. Copies (textual copy, without load/export) the manifest into the index
clone.
        1. This preserves the maintainer formatting.
        1. "Copy" means here to replace the general section, and append the new
release after previous ones already existing.
    1. Verifies that the release is `alr get`-able using the modified index.
        1. This provides minimal insurance that the submission is in good
shape.
    1. The PR can be created manually or automatically.

The key change is that, by copying the manifest file contents as-is, there is
no mangling of the TOML contents, and the pitfall of automated edition is
avoided.

References
==========

1. Rust Cargo `Crate.toml` file.
    - https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
1. Python `pip` `requirements.txt` file.
    - https://pip.pypa.io/en/stable/user_guide/#requirements-files

Copyright
=========

This document has been placed in the public domain.
