with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Ada.Directories;
with Ada.Text_IO;
with Ada.Characters.Handling;

with Alire_Early_Elaboration;
with Alire.Solutions;
with Alire.Roots;
with Alire.Utils.TTY;
with Alire.Origins;

with GNAT.IO;

with Alire.Directories;

with TOML; use TOML;

package body Alire.Crate_Configuration is

   package TTY renames Utils.TTY;
   package TIO renames Ada.Text_IO;

   ----------
   -- Load --
   ----------

   procedure Load (This : in out Global_Config;
                   Root :        Alire.Roots.Root)
   is
      Solution : constant Solutions.Solution := Root.Solution;
   begin

      --  Warnings when setting up an incomplete environment

      if not Solution.Is_Complete then
         Trace.Debug ("Generating incomplete environment"
                      & " because of missing dependencies");

         --  Normally we would generate a warning, but since that will pollute
         --  the output making it unusable, for once we write directly to
         --  stderr (unless quiet is in effect):

         if not Alire_Early_Elaboration.Switch_Q then
            GNAT.IO.Put_Line
              (GNAT.IO.Standard_Error,
               TTY.Warn ("warn:") & " Generating incomplete environment"
               & " because of missing dependencies");
         end if;
      end if;

      for Rel of Solution.Releases.Including (Root.Release) loop
         This.Load_Definitions (Root  => Root,
                                Crate => Rel.Name);
      end loop;

      for Rel of Solution.Releases.Including (Root.Release) loop
         This.Load_Settings (Root  => Root,
                             Crate => Rel.Name);
      end loop;

      Use_Default_Values (This);
   end Load;

   ---------------------------
   -- Generate_Config_Files --
   ---------------------------

   procedure Generate_Config_Files (This : Global_Config;
                                    Root : Alire.Roots.Root)
   is
      use Alire.Directories;
      use Alire.Origins;

      Solution : constant Solutions.Solution := Root.Solution;
   begin

      --  Warnings when setting up an incomplete environment

      if not Solution.Is_Complete then
         Trace.Debug ("Generating incomplete environment"
                      & " because of missing dependencies");

         --  Normally we would generate a warning, but since that will pollute
         --  the output making it unusable, for once we write directly to
         --  stderr (unless quiet is in effect):

         if not Alire_Early_Elaboration.Switch_Q then
            GNAT.IO.Put_Line
              (GNAT.IO.Standard_Error,
               TTY.Warn ("warn:") & " Generating incomplete environment"
               & " because of missing dependencies");
         end if;
      end if;

      for Rel of Solution.Releases.Including (Root.Release) loop

         --  We don't create config files for external releases, since they are
         --  not sources built by Alire.
         if Rel.Origin.Kind /= Alire.Origins.External then

            declare
               Conf_Dir : constant Absolute_Path :=
                 Root.Release_Base (Rel.Name) / "config";
            begin
               Ada.Directories.Create_Path (Conf_Dir);

               This.Generate_Ada_Config
                 (Rel.Name, Conf_Dir / (+Rel.Name & "_config.ads"));

               This.Generate_GPR_Config
                 (Rel.Name,
                  Conf_Dir / (+Rel.Name & "_config.gpr"),
                  Root.Direct_Withs (Rel));

               This.Generate_C_Config
                 (Rel.Name, Conf_Dir / (+Rel.Name & "_config.h"));
            end;
         end if;
      end loop;
   end Generate_Config_Files;

   -------------------------
   -- Generate_Ada_Config --
   -------------------------

   procedure Generate_Ada_Config (This     : Global_Config;
                                  Crate    : Crate_Name;
                                  Filepath : Absolute_Path)
   is
      File : TIO.File_Type;

   begin

      TIO.Create (File, TIO.Out_File, Filepath);

      TIO.Put_Line
        (File, "--  Configuration for " & (+Crate) & " generated by Alire");

      TIO.Put_Line (File, "package " & (+Crate) & "_Config is");
      for C in This.Map.Iterate loop
         declare
            Elt : constant Config_Maps.Constant_Reference_Type :=
              This.Map.Constant_Reference (C);

            Type_Def : Config_Type_Definition renames Elt.Type_Def.Element;

            Key : constant String := To_String (Config_Maps.Key (C));
         begin
            if Elt.Value = TOML.No_TOML_Value then
               Raise_Checked_Error
                 ("Configuration variable should be set at this point." &
                    " Missing call to Use_Default_Values()?");
            end if;

            if Alire.Utils.Starts_With (Key, +Crate & ".") then
               TIO.New_Line (File);
               TIO.Put_Line (File, Type_Def.To_Ada_Declaration (Elt.Value));
            end if;
         end;
      end loop;
      TIO.New_Line (File);
      TIO.Put_Line (File, "end " & (+Crate) & "_Config;");
      TIO.Close (File);
   end Generate_Ada_Config;

   -------------------------
   -- Generate_GPR_Config --
   -------------------------

   procedure Generate_GPR_Config (This     : Global_Config;
                                  Crate    : Crate_Name;
                                  Filepath : Absolute_Path;
                                  Withs    : Alire.Utils.String_Set)
   is
      File : TIO.File_Type;

   begin

      TIO.Create (File, TIO.Out_File, Filepath);

      TIO.Put_Line
        (File, "--  Configuration for " & (+Crate) & " generated by Alire");

      for W of Withs loop
         TIO.Put_Line (File, "with """ & W & """;");
      end loop;

      TIO.Put_Line (File, "abstract project " & (+Crate) & "_Config is");
      for C in This.Map.Iterate loop
         declare
            Elt : constant Config_Maps.Constant_Reference_Type :=
              This.Map.Constant_Reference (C);

            Type_Def : Config_Type_Definition renames Elt.Type_Def.Element;

            Key : constant String := To_String (Config_Maps.Key (C));
         begin
            if Elt.Value = TOML.No_TOML_Value then
               Raise_Checked_Error
                 ("Configuration variable should be set at this point." &
                    " Missing call to Use_Default_Values()?");
            end if;

            if Alire.Utils.Starts_With (Key, +Crate & ".") then
               TIO.New_Line (File);
               TIO.Put_Line (File, Type_Def.To_GPR_Declaration (Elt.Value));
            end if;
         end;
      end loop;

      TIO.New_Line (File);
      TIO.Put_Line (File, "end " & (+Crate) & "_Config;");
      TIO.Close (File);
   end Generate_GPR_Config;

   -----------------------
   -- Generate_C_Config --
   -----------------------

   procedure Generate_C_Config (This     : Global_Config;
                                Crate    : Crate_Name;
                                Filepath : Absolute_Path)
   is
      File : TIO.File_Type;

      Crate_Upper : constant String :=
        Ada.Characters.Handling.To_Upper (+Crate);

   begin

      TIO.Create (File, TIO.Out_File, Filepath);

      TIO.Put_Line
        (File, "/* Configuration for " & (+Crate) & " generated by Alire */");
      TIO.Put_Line (File, "#ifndef " & Crate_Upper & "_CONFIG_H");
      TIO.Put_Line (File, "#define " & Crate_Upper & "_CONFIG_H");
      for C in This.Map.Iterate loop
         declare
            Elt : constant Config_Maps.Constant_Reference_Type :=
              This.Map.Constant_Reference (C);

            Type_Def : Config_Type_Definition renames Elt.Type_Def.Element;

            Key : constant String := To_String (Config_Maps.Key (C));
         begin
            if Elt.Value = TOML.No_TOML_Value then
               Raise_Checked_Error
                 ("Configuration variable should be set at this point." &
                    " Missing call to Use_Default_Values()?");
            end if;

            if Alire.Utils.Starts_With (Key, +Crate & ".") then
               TIO.New_Line (File);
               TIO.Put_Line (File, Type_Def.To_C_Declaration (Elt.Value));
            end if;
         end;
      end loop;
      TIO.New_Line (File);
      TIO.Put_Line (File, "#endif");
      TIO.Close (File);
   end Generate_C_Config;

   ----------------------
   -- Load_Definitions --
   ----------------------

   procedure Load_Definitions (This  : in out Global_Config;
                               Root  : Roots.Root;
                               Crate : Crate_Name)
   is

      --------------------
      -- Add_Definition --
      --------------------

      procedure Add_Definition (Type_Def : Config_Type_Definition) is
         Type_Name_Lower : constant String :=
           Ada.Characters.Handling.To_Lower (Type_Def.Name);

         Name : constant Unbounded_String := +(+Crate & "." & Type_Name_Lower);
      begin
         if This.Map.Contains (Name) then
            Raise_Checked_Error
              ("Configuration variable '" & (+Name) & "' already defined");
         end if;

         declare
            Setting : Config_Setting;
         begin
            Setting.Type_Def.Replace_Element (Type_Def);
            Setting.Value := TOML.No_TOML_Value;
            This.Map.Insert (Name, Setting);
         end;
      end Add_Definition;

      Rel : constant Releases.Release := Root.Release (Crate);

   begin
      for Prop of Rel.On_Platform_Properties (Root.Environment,
                                              Config_Type_Definition'Tag)
      loop
         Add_Definition (Config_Type_Definition (Prop));
      end loop;
   end Load_Definitions;

   -------------------
   -- Load_Settings --
   -------------------

   procedure Load_Settings (This  : in out Global_Config;
                            Root  : Roots.Root;
                            Crate : Crate_Name)
   is

      Rel : constant Releases.Release := Root.Release (Crate);

      ---------------
      -- Set_Value --
      ---------------

      procedure Set_Value (Crate : Unbounded_String; Val : Assignment) is
         Val_Name_Lower : constant String :=
           Ada.Characters.Handling.To_Lower (+Val.Name);
         Name : constant Unbounded_String := Crate & "." & Val_Name_Lower;
      begin

         --  TODO check if setting configuration of a dependency

         if not This.Map.Contains (Name) then
            Raise_Checked_Error
              ("Unknown configuration variable '" & (+Name) & "'");
         end if;

         declare
            Ref : constant Config_Maps.Reference_Type :=
              This.Map.Reference (Name);
         begin

            if not Valid (Ref.Type_Def.Element, Val.Value) then
               Raise_Checked_Error
                 ("Invalid value from '" & (+Crate) &
                    "'" & " for type " & Image (Ref.Type_Def.Element));
            end if;

            if Ref.Value /= No_TOML_Value and then Ref.Value /= Val.Value then
               Raise_Checked_Error
                 ("Conflicting value for configuration variable '" &
                  (+Name) & "' from '" & (+Ref.Set_By) & "' and '"
                  & (+Crate) & "'.");
            else
               Ref.Value := Val.Value;
               Ref.Set_By := +(+Crate);
            end if;
         end;
      end Set_Value;

   begin

      for Prop of Rel.On_Platform_Properties (Root.Environment,
                                              Config_Value_Assignment'Tag)
      loop
         declare
            List : Config_Value_Assignment renames
              Config_Value_Assignment (Prop);
         begin
            for Elt of List.List loop
               Set_Value (List.Crate, Elt);
            end loop;
         end;
      end loop;

   end Load_Settings;

   ------------------------
   -- Use_Default_Values --
   ------------------------

   procedure Use_Default_Values (Conf : in out Global_Config) is
   begin
      for C in Conf.Map.Iterate loop
         declare
            Elt : constant Config_Maps.Reference_Type :=
              Conf.Map.Reference (C);

            Key : constant String := To_String (Config_Maps.Key (C));
         begin
            if Elt.Value = TOML.No_TOML_Value then
               if Elt.Type_Def.Element.Default /= No_TOML_Value then
                  Elt.Value := Elt.Type_Def.Element.Default;
                  Elt.Set_By := +"default value";
               else
                  Raise_Checked_Error
                    ("Configuration variable '" & Key &
                       " not set and has no default value.");
               end if;
            end if;
         end;
      end loop;
   end Use_Default_Values;

end Alire.Crate_Configuration;
